---
# tasks file for qb.release_gem

- name: get gem and version info
  vars.rb:
    namespace: release_gem
    bind:
      qb_dir: "{{ qb_dir }}"
    src: |
      spec_pattern = "#{ qb_dir }/*.gemspec"
      spec_path = Dir.glob(spec_pattern)[0]
      
      if spec_path.nil?
        raise "No gemspec found for pattern #{ spec_pattern }"
      end
      
      spec = Gem::Specification.load spec_path
      
      # The gem *may already be loaded*, which would break the standard gemspec
      # approach because the `require` will be a no-op, resulting in the 
      # already loaded version number being used instead of the one in the
      # file.
      # 
      # This is only a problem for NRSER, which is loaded in vars.rb.rb, but
      # this fix should work for any module without worrying about what is
      # currently loaded... grab the info we need in a clean child process.
      # 
      code = <<-END
        require 'json'
        spec = Gem::Specification.load(#{ JSON.dump spec_path })
        puts JSON.dump({
          'version' => spec.version.version,
          'name' => spec.name,
        })
      END
      obj = JSON.load `ruby -e #{ code.shellescape }`
      version = Gem::Version.new obj['version']
      name = obj['name']
      
      segments = version.segments.dup
      segments.pop while segments.any? {|s| s.is_a? String}
      
      segments[-1] = segments[-1].succ
      segments << 'dev'
      
      next_version = segments.join('.')
      
      {
        'name' => name,
        'current_version' => version.version,
        'release_version' => version.release,
        'next_version' => next_version,
        'version_path' => "#{ qb_dir }/lib/#{ name }/version.rb",
        'spec_path' => spec_path,
      }
  
- debug:
    msg:
    # - spec_path: >-
    #     {{ release_gem_spec_path }}
    # - version_path: >-
    #     {{ release_gem_version_path }}
    - current: >-
        {{ release_gem_current_version }}
    - release: >-
        {{ release_gem_release_version }}
    - next: >-
        {{ release_gem_next_version }}

- name: "change version to release version {{ release_gem_release_version }}"
  replace:
    dest: "{{ release_gem_version_path }}"
    regexp: "VERSION\\s*=\\s*\"{{ release_gem_current_version }}\""
    replace: "VERSION = \"{{ release_gem_release_version }}\""
  when: release_gem_current_version != release_gem_release_version

- name: add release version to git
  command: "git add {{ release_gem_version_path }}"
  args:
    chdir: "{{ qb_dir }}"
  when: release_gem_current_version != release_gem_release_version

- name: commit release version
  command: git commit -m "bump to v{{ release_gem_release_version }}"
  args:
    chdir: "{{ qb_dir }}"
  when: release_gem_current_version != release_gem_release_version

- name: release with bundler
  shell: bundle exec rake release
  args:
    chdir: "{{ qb_dir }}"

- name: "change version to next version {{ release_gem_next_version }}"
  replace:
    dest: "{{ release_gem_version_path }}"
    regexp: "VERSION\\s*=\\s*\"{{ release_gem_release_version }}\""
    replace: "VERSION = \"{{ release_gem_next_version }}\""

- name: add next dev version to git
  command: "git add {{ release_gem_version_path }}"
  args:
    chdir: "{{ qb_dir }}"

- name: commit next dev version
  command: git commit -m "start {{ release_gem_next_version }}"
  args:
    chdir: "{{ qb_dir }}"

- name: push next dev version
  command: git push
  args:
    chdir: "{{ qb_dir }}"

- debug:
    msg: >
      v{{ release_gem_release_version }} released.
