#!/usr/bin/env ruby
# WANT_JSON

# Basically, I was wanting a lower-friction way to write Ansible modules in
# since it's so painful to do very basic, common programming logic in
# Ansible files, and their Python module framework is also very heavy and
# clunky for quick and dirty tasks.
# 
# Ruby seems like it would be the way to go here since it offers so much
# flexibility and power creating quick DSLs.
# 
# The idea is that it should really just read and run like a very simple
# script.
# 
# ALSO, I really want modules to be easily compossible... something that seems
# tremendously overlooked in Ansible, though it would probably be OK if that
# was part of the "more serious" class-style modules like what already exists
# in {QB::Ansible::Module} and not a part of the scripting DSL / API
# 

# init bundler in dev env
if ENV['QB_DEV_ENV']; ENV.each {|k, v| if k.start_with? 'QB_DEV_ENV_' then \
  ENV[k.sub('QB_DEV_ENV_', '')] = v; end }; require 'bundler/setup'; end

require 'qb'

# This would do all the magic
include QB::Ansible::Module::Script

# `args` should be set up to have the incoming arguments from Ansible (or
# a test harness or CLI or whatever). Kind like Beizo, overload the hash-style
# accessor to accept a type and check it.
# 
bundle_root = args[:bundle_root, NRSER::Types.abs_path]

# This is just a little util method. Want to just be able to declare at top
# scope like this and not worry about it.
def set_facts output_dir
  # `facts` is added by the script include, and is just a hash-like where you
  # can set facts to send back to the playbook
  facts[:yard_output_dir] = rel_dir
  facts[:yard_output_abs_dir] = File.expand_path( rel_dir, bundle_root )
end

path = File.join bundle_root, '.yardopts'

if File.exists? path
  if match = /^\-\-output-dir[\s\=](.*)$/.match( File.read( path ) )
    set_facts match[1]
    # Some sort of exit / escape mechanism... might even just be able to tie
    # into `exit` with a finalizer of sorts..?
    done!
  end
end

set_facts 'doc'

# Dropping off the end should result in the respond being printed, so I guess
# we do need some exit finalizer.. looks like it's pretty easy (thanks Ruby!):
# 
# https://ruby-doc.org/core-2.2.3/Kernel.html#method-i-at_exit
# 
